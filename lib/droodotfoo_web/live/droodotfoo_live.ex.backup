defmodule DroodotfooWeb.DroodotfooLive do
  use DroodotfooWeb, :live_view
  alias Droodotfoo.TerminalBridge
  alias Droodotfoo.{RaxolApp, AdaptiveRefresh, InputDebouncer, InputRateLimiter, BootSequence}
  alias DroodotfooWeb.Live.ConnectionRecovery
  alias Droodotfoo.Content.Posts
  alias Droodotfoo.Web3.Auth

  @impl true
  def mount(_params, _session, socket) do
    # Record page request
    Droodotfoo.PerformanceMonitor.record_request()

    # Use the existing RaxolApp process (started in supervision tree)
    raxol_pid = Process.whereis(RaxolApp) || RaxolApp

    # Initialize performance optimization systems
    adaptive_refresh = AdaptiveRefresh.new()
    input_debouncer = InputDebouncer.new(InputDebouncer.config_for_mode(:navigation))
    rate_limiter = InputRateLimiter.new()

    # Start boot sequence on connected socket
    if connected?(socket) do
      # Schedule first boot step
      delay = BootSequence.delay_for_step(1)
      Process.send_after(self(), :boot_next_step, delay)

      # Generate initial boot display
      boot_html = render_boot_sequence(0)

      # Load latest posts for homepage
      latest_posts =
        try do
          Posts.list_posts() |> Enum.take(5)
        rescue
          _ -> []
        end

      {:ok,
       socket
       |> assign(:raxol_pid, raxol_pid)
       |> assign(:terminal_html, boot_html)
       |> assign(:boot_in_progress, true)
       |> assign(:boot_step, 0)
       |> assign(:current_section, :home)
       |> assign(:last_render_time, System.monotonic_time(:millisecond))
       |> assign(:connection_recovery, ConnectionRecovery.new())
       |> assign(:adaptive_refresh, adaptive_refresh)
       |> assign(:input_debouncer, input_debouncer)
       |> assign(:rate_limiter, rate_limiter)
       |> assign(:last_buffer_hash, 0)
       |> assign(:performance_mode, :normal)
       |> assign(:tick_timer, nil)
       |> assign(:vim_mode, false)
       |> assign(:loading, false)
       |> assign(:breadcrumb_path, ["Home"])
       |> assign(:current_theme, "theme-synthwave84")
       |> assign(:crt_mode, false)
       |> assign(:high_contrast_mode, false)
       |> assign(:screen_reader_message, "Welcome to droo.foo")
       |> assign(:terminal_visible, false)
       |> assign(:latest_posts, latest_posts)}
    else
      # Not connected yet, show blank screen but still load posts
      latest_posts =
        try do
          Posts.list_posts() |> Enum.take(5)
        rescue
          _ -> []
        end

      {:ok,
       socket
       |> assign(:raxol_pid, raxol_pid)
       |> assign(:terminal_html, "")
       |> assign(:boot_in_progress, false)
       |> assign(:boot_step, 0)
       |> assign(:current_section, :home)
       |> assign(:last_render_time, System.monotonic_time(:millisecond))
       |> assign(:connection_recovery, ConnectionRecovery.new())
       |> assign(:adaptive_refresh, adaptive_refresh)
       |> assign(:input_debouncer, input_debouncer)
       |> assign(:rate_limiter, rate_limiter)
       |> assign(:last_buffer_hash, 0)
       |> assign(:performance_mode, :normal)
       |> assign(:tick_timer, nil)
       |> assign(:vim_mode, false)
       |> assign(:loading, false)
       |> assign(:breadcrumb_path, ["Home"])
       |> assign(:current_theme, "theme-synthwave84")
       |> assign(:crt_mode, false)
       |> assign(:high_contrast_mode, false)
       |> assign(:screen_reader_message, "Welcome to droo.foo")
       |> assign(:terminal_visible, false)
       |> assign(:latest_posts, latest_posts)}
    end
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="site-container" role="main">
      <!-- Terminal Toggle Button (always visible) -->
      <button
        class="terminal-toggle"
        phx-click="toggle_terminal"
        data-tooltip="Terminal (`)"
        aria-label="Toggle Terminal (backtick key)"
      >
        {if @terminal_visible, do: "×", else: "`"}
      </button>
      
    <!-- Screen reader announcements -->
      <div
        id="screen-reader-announcements"
        role="status"
        aria-live="polite"
        aria-atomic="true"
        class="sr-only"
      >
        {assigns[:screen_reader_message] || ""}
      </div>
      
    <!-- Connection status indicator -->
      <%= if assigns[:connection_recovery] do %>
        <% status_info = ConnectionRecovery.get_status_display(@connection_recovery) %>
        <%= if status_info.show do %>
          <div class={"connection-status #{status_info.class}"} role="status" aria-live="polite">
            {status_info.status}
          </div>
        <% end %>
      <% end %>
      
    <!-- Loading indicator -->
      <%= if @loading do %>
        <div class="loading-indicator" role="status" aria-live="polite">
          <div class="loading-spinner" aria-hidden="true"></div>
          <span>Loading...</span>
        </div>
      <% end %>
      
    <!-- Terminal Overlay (always rendered, visibility controlled by CSS) -->
      <div class={"terminal-overlay #{if @terminal_visible, do: "active", else: ""}"}>
        <div
          class={"terminal-wrapper #{if @crt_mode, do: "crt-mode", else: ""} #{if @high_contrast_mode, do: "high-contrast", else: ""}"}
          id="terminal-wrapper"
          role="application"
          aria-label="Interactive terminal interface"
          phx-hook="TerminalHook"
          phx-window-keydown="key_press"
          tabindex="0"
        >
          <!-- Terminal buffer HTML -->
          {raw(@terminal_html)}
          
    <!-- Hidden input for keyboard capture inside the hook element -->
          <input
            id="terminal-input"
            type="text"
            phx-keydown="key_press"
            phx-key="Enter"
            style="position: absolute; left: -9999px; top: 0;"
            autofocus
          />
        </div>
      </div>
      
    <!-- Homepage View (always rendered) -->
      <div class="monospace-container">
        <header class="post-header" style="margin-bottom: 2rem;">
          <div class="post-header-grid">
            <div class="post-header-content">
              <h1 class="post-title" style="font-size: 2rem;">DROO.FOO</h1>
              <p class="post-description">
                Building axol.io
              </p>
            </div>
            <div class="post-header-meta">
              <div class="meta-row">
                <span class="meta-label">Version</span>
                <span class="meta-value">v1.0.0</span>
              </div>
              <div class="meta-row">
                <span class="meta-label">Updated</span>
                <span class="meta-value">{Date.to_string(Date.utc_today())}</span>
              </div>
              <div class="meta-row">
                <span class="meta-label">Author</span>
                <span class="meta-value">
                  <a
                    href="https://github.com/hydepwns"
                    target="_blank"
                    rel="noopener"
                    style="color: inherit; text-decoration: underline;"
                  >
                    Hydepwns
                  </a>
                </span>
              </div>
            </div>
          </div>
        </header>

        <%= if length(@latest_posts) > 0 do %>
          <section style="margin-bottom: 2rem;">
            <h2 style="border-bottom: 2px solid var(--border-color); padding-bottom: 0.5rem; margin-bottom: 1rem;">
              LATEST POSTS
            </h2>
            <%= for post <- @latest_posts do %>
              <article class="box-single" style="margin-bottom: 1rem;">
                <h3 style="margin-bottom: 0.5rem;">
                  <a
                    href={"/posts/#{post.slug}"}
                    style="text-decoration: none; color: var(--text-color);"
                  >
                    {post.title}
                  </a>
                </h3>
                <p style="color: var(--text-color-alt); font-size: 0.875rem; margin-bottom: 0.5rem;">
                  {Date.to_string(post.date)} • {post.read_time} min read
                </p>
                <p>{post.description}</p>
              </article>
            <% end %>
          </section>
        <% end %>

        <section style="margin-bottom: 2rem;">
          <h2 style="border-bottom: 2px solid var(--border-color); padding-bottom: 0.5rem; margin-bottom: 1rem;">
            QUICK LINKS
          </h2>
          <ul style="list-style: none; padding: 0;">
            <li style="margin-bottom: 0.5rem;">
              <a href="#" phx-click="toggle_terminal" style="text-decoration: none;">
                → Open Terminal (or press backtick)
              </a>
            </li>
            <li style="margin-bottom: 0.5rem;">
              <a
                href="https://github.com/hydepwns"
                target="_blank"
                rel="noopener"
                style="text-decoration: none;"
              >
                → GitHub Profile
              </a>
            </li>
          </ul>
        </section>

        <footer class="instructions-box" style="margin-top: auto;">
          <span id="site-footer" phx-update="ignore">No tracking/analytics</span>
        </footer>
      </div>
    </div>
    """
  end

  @impl true
  def handle_info(:boot_next_step, socket) do
    next_step = socket.assigns.boot_step + 1

    if BootSequence.complete?(next_step) do
      # Boot sequence complete, transition to normal terminal
      initial_buffer = RaxolApp.get_buffer(socket.assigns.raxol_pid)
      initial_html = TerminalBridge.terminal_to_html(initial_buffer)
      initial_buffer_hash = :erlang.phash2(initial_buffer)

      # Start normal tick cycle
      schedule_next_tick(socket.assigns.adaptive_refresh)

      {:noreply,
       socket
       |> assign(:boot_in_progress, false)
       |> assign(:terminal_html, initial_html)
       |> assign(:last_buffer_hash, initial_buffer_hash)}
    else
      # Advance to next boot step
      boot_html = render_boot_sequence(next_step)

      # Schedule next step
      next_delay = BootSequence.delay_for_step(next_step + 1)
      Process.send_after(self(), :boot_next_step, next_delay)

      {:noreply,
       socket
       |> assign(:boot_step, next_step)
       |> assign(:terminal_html, boot_html)}
    end
  end

  @impl true
  def handle_info({:update_connection_status, status}, socket) do
    # Update connection recovery status
    recovery = %{socket.assigns.connection_recovery | status: status}
    {:noreply, assign(socket, :connection_recovery, recovery)}
  end

  def handle_info({:stl_viewer_quit, _viewer_id}, socket) do
    # Navigate back to home when STL viewer quits
    RaxolApp.send_input(socket.assigns.raxol_pid, "q")

    {:noreply,
     socket
     |> assign(:current_section, :home)
     |> assign(:breadcrumb_path, section_to_breadcrumb(:home))
     |> assign(:screen_reader_message, announce_section_change(:home))}
  end

  def handle_info({:DOWN, _ref, :process, _pid, _reason}, socket) do
    recovery = ConnectionRecovery.handle_disconnect(socket.assigns.connection_recovery)
    recovery = ConnectionRecovery.attempt_reconnect(recovery)

    # Schedule reconnection attempt
    :timer.send_after(1000, self(), :attempt_reconnect)

    {:noreply, assign(socket, :connection_recovery, recovery)}
  end

  def handle_info(:attempt_reconnect, socket) do
    recovery = socket.assigns.connection_recovery

    if recovery.status == :reconnecting do
      # Try to reconnect by starting a new tick cycle
      if connected?(socket) do
        recovery = ConnectionRecovery.handle_reconnect_success(recovery)
        {queued_commands, recovery} = ConnectionRecovery.flush_queued_commands(recovery)

        # Process any queued commands
        Enum.each(queued_commands, fn command ->
          RaxolApp.send_input(socket.assigns.raxol_pid, command)
        end)

        {:noreply,
         socket
         |> assign(:connection_recovery, recovery)
         |> assign(:connection_status, :connected)}
      else
        # Still not connected, schedule another attempt
        :timer.send_after(2000, self(), :attempt_reconnect)
        {:noreply, socket}
      end
    else
      {:noreply, socket}
    end
  end

  def handle_info({:debounce_timeout, :input}, socket) do
    {keys, debouncer} = InputDebouncer.handle_timeout(socket.assigns.input_debouncer)
    Enum.each(keys, &RaxolApp.send_input(socket.assigns.raxol_pid, &1))

    {:noreply, assign(socket, :input_debouncer, debouncer)}
  end

  @impl true
  def handle_info(:tick, socket) do
    # Skip tick processing during boot sequence
    if socket.assigns.boot_in_progress do
      {:noreply, socket}
    else
      adaptive = socket.assigns.adaptive_refresh

      # Check if we should render based on adaptive refresh rate
      if AdaptiveRefresh.should_render?(adaptive) do
        process_tick_render(socket, adaptive)
      else
        # Skip this tick, schedule next one
        schedule_next_tick(adaptive)
        {:noreply, socket}
      end
    end
  end

  # Catch-all for unexpected messages to prevent crashes
  def handle_info(msg, socket) do
    # Log unexpected messages in development
    if Mix.env() != :prod do
      IO.inspect(msg, label: "Unexpected message in DroodotfooLive")
    end

    {:noreply, socket}
  end

  defp process_tick_render(socket, adaptive) do
    start_time = System.monotonic_time(:millisecond)

    # Get current terminal buffer from Raxol
    buffer = RaxolApp.get_buffer(socket.assigns.raxol_pid)

    # Calculate buffer hash for dirty checking
    buffer_hash = :erlang.phash2(buffer)

    # Only render if buffer has changed
    {html, should_update} =
      if buffer_hash != socket.assigns.last_buffer_hash do
        # Use terminal bridge for HTML generation
        rendered_html = TerminalBridge.terminal_to_html(buffer)
        {rendered_html, true}
      else
        {socket.assigns.terminal_html, false}
      end

    # Calculate render time
    render_time = System.monotonic_time(:millisecond) - start_time

    # Record render in adaptive refresh
    adaptive = AdaptiveRefresh.record_render(adaptive, render_time)

    # Process all state changes
    socket = process_state_changes(socket)

    # Only record metrics for actual renders
    if should_update do
      Droodotfoo.PerformanceMonitor.record_render_time(render_time)
      # Push event to JS to verify grid alignment
      push_event(socket, "terminal_updated", %{})
    end

    # Schedule next tick based on adaptive refresh rate
    schedule_next_tick(adaptive)

    {:noreply,
     socket
     |> assign(:terminal_html, html)
     |> assign(:last_render_time, render_time)
     |> assign(:adaptive_refresh, adaptive)
     |> assign(
       :last_buffer_hash,
       if(should_update, do: buffer_hash, else: socket.assigns.last_buffer_hash)
     )}
  end

  defp process_state_changes(socket) do
    socket
    |> process_section_changes()
    |> process_theme_changes()
    |> process_stl_actions()
    |> process_spotify_actions()
    |> process_web3_actions()
    |> process_crt_mode_changes()
    |> process_high_contrast_changes()
  end

  defp process_section_changes(socket) do
    current_section = RaxolApp.get_current_section(socket.assigns.raxol_pid)
    section_changed = current_section != socket.assigns.current_section

    if section_changed do
      breadcrumb = section_to_breadcrumb(current_section)
      sr_message = announce_section_change(current_section)

      socket
      |> assign(:current_section, current_section)
      |> assign(:breadcrumb_path, breadcrumb)
      |> assign(:loading, false)
      |> assign(:screen_reader_message, sr_message)
      |> push_event("section_changed", %{section: Atom.to_string(current_section)})
    else
      socket
    end
  end

  defp process_theme_changes(socket) do
    theme_change = RaxolApp.get_theme_change(socket.assigns.raxol_pid)

    if theme_change do
      socket
      |> assign(:current_theme, theme_change)
      |> push_event("theme_changed", %{theme: theme_change})
    else
      socket
    end
  end

  defp process_stl_actions(socket) do
    stl_action = RaxolApp.get_stl_viewer_action(socket.assigns.raxol_pid)

    if stl_action do
      handle_stl_viewer_action(socket, stl_action)
    else
      socket
    end
  end

  defp process_spotify_actions(socket) do
    spotify_action = RaxolApp.get_spotify_action(socket.assigns.raxol_pid)

    if spotify_action do
      handle_spotify_action(socket, spotify_action)
    else
      socket
    end
  end

  defp process_web3_actions(socket) do
    web3_action = RaxolApp.get_web3_action(socket.assigns.raxol_pid)

    if web3_action do
      handle_web3_action(socket, web3_action)
    else
      socket
    end
  end

  defp process_crt_mode_changes(socket) do
    crt_mode = RaxolApp.get_crt_mode(socket.assigns.raxol_pid)

    if crt_mode != socket.assigns[:crt_mode] do
      assign(socket, :crt_mode, crt_mode)
    else
      socket
    end
  end

  defp process_high_contrast_changes(socket) do
    high_contrast_mode = RaxolApp.get_high_contrast_mode(socket.assigns.raxol_pid)

    if high_contrast_mode != socket.assigns[:high_contrast_mode] do
      assign(socket, :high_contrast_mode, high_contrast_mode)
    else
      socket
    end
  end

  @impl true
  def handle_event("set_vim_mode", %{"enabled" => enabled}, socket) do
    # Set vim mode from client (loaded from localStorage)
    RaxolApp.send_input(
      socket.assigns.raxol_pid,
      if(enabled, do: "set_vim_on", else: "set_vim_off")
    )

    {:noreply, assign(socket, :vim_mode, enabled)}
  end

  @impl true
  def handle_event("restore_section", %{"section" => section_str}, socket) do
    # Restore section from localStorage
    section_atom = String.to_existing_atom(section_str)
    breadcrumb = section_to_breadcrumb(section_atom)

    # Send to RaxolApp to restore state
    RaxolApp.send_input(socket.assigns.raxol_pid, "restore_section:#{section_str}")

    {:noreply,
     socket
     |> assign(:current_section, section_atom)
     |> assign(:breadcrumb_path, breadcrumb)}
  catch
    _kind, _reason ->
      # Invalid section, ignore
      {:noreply, socket}
  end

  @impl true
  def handle_event("set_theme", %{"theme" => theme}, socket) do
    # Set theme from client (loaded from localStorage)
    {:noreply, assign(socket, :current_theme, theme)}
  end

  @impl true
  def handle_event("change_theme", %{"theme" => theme}, socket) do
    # Theme changed via dropdown
    {:noreply,
     socket
     |> assign(:current_theme, theme)
     |> push_event("theme_changed", %{theme: theme})}
  end

  @impl true
  def handle_event("toggle_terminal", _params, socket) do
    new_state = !socket.assigns.terminal_visible

    {:noreply,
     socket
     |> assign(:terminal_visible, new_state)
     |> push_event("save_terminal_pref", %{visible: new_state})}
  end

  @impl true
  def handle_event("set_terminal_visible", %{"visible" => visible}, socket) do
    # Restore terminal visibility from localStorage
    {:noreply, assign(socket, :terminal_visible, visible)}
  end

  # STL Viewer event handlers (from hook)
  def handle_event(
        "model_loaded",
        %{"triangles" => _triangles, "vertices" => _vertices, "bounds" => _bounds},
        socket
      ) do
    # Event handled successfully - component manages its own state
    {:noreply, socket}
  end

  def handle_event("model_error", %{"error" => _error}, socket) do
    # Event handled successfully - component manages its own state
    {:noreply, socket}
  end

  def handle_event("cell_click", %{"row" => row, "col" => col}, socket) do
    # Debug logging
    IO.inspect({:cell_click, row, col}, label: "Cell clicked")

    # Handle cell click - navigation menu is at rows 15-20, cols 0-29
    # Row 15 = Home (idx 0)
    # Row 16 = Projects (idx 1)
    # Row 17 = Skills (idx 2)
    # Row 18 = Experience (idx 3)
    # Row 19 = Contact (idx 4)
    # Row 20 = STL Viewer (idx 5)

    nav_start_row = 15
    nav_end_row = 20
    nav_start_col = 0
    nav_end_col = 29

    if row >= nav_start_row and row <= nav_end_row and
         col >= nav_start_col and col <= nav_end_col do
      IO.puts("Navigation clicked! menu_idx: #{row - nav_start_row}")
      # Calculate which menu item was clicked
      menu_idx = row - nav_start_row

      # Send cursor movement and selection to RaxolApp
      # First move cursor to the item
      RaxolApp.send_input(socket.assigns.raxol_pid, "cursor_set:#{menu_idx}")
      # Then select it
      RaxolApp.send_input(socket.assigns.raxol_pid, "Enter")

      # Mark as dirty for immediate render
      adaptive = AdaptiveRefresh.mark_dirty(socket.assigns.adaptive_refresh)
      {:noreply, assign(socket, :adaptive_refresh, adaptive)}
    else
      {:noreply, socket}
    end
  end

  def handle_event("recalculate_grid", _params, socket) do
    # Trigger grid recalculation after font size change
    buffer = RaxolApp.get_buffer(socket.assigns.raxol_pid)

    # Use terminal bridge for HTML generation
    html_content = Droodotfoo.TerminalBridge.terminal_to_html(buffer)

    # Send updated HTML to client
    {:noreply, push_event(socket, "update_grid", %{html: html_content})}
  end

  @impl true
  def handle_event("key_press", %{"key" => key}, socket) do
    # Backtick always toggles terminal, even during boot
    if key == "`" do
      handle_backtick_key(socket)
    else
      handle_other_key(key, socket)
    end
  end

  # Handle Web3 wallet connection success from JavaScript hook
  def handle_event(
        "web3_connect_success",
        %{
          "address" => address,
          "chainId" => chain_id,
          "signature" => signature,
          "nonce" => nonce
        },
        socket
      ) do
    # Verify the signature and recover the address
    case Auth.verify_signature(address, nonce, signature) do
      {:ok, verified_address} ->
        # Store the wallet session
        Droodotfoo.Web3.start_session(verified_address, chain_id)

        # Update RaxolApp state
        RaxolApp.set_web3_wallet(socket.assigns.raxol_pid, verified_address, chain_id)

        {:noreply, socket}

      {:error, _reason} ->
        # Authentication failed
        {:noreply,
         push_event(socket, "web3_auth_failed", %{error: "Signature verification failed"})}
    end
  end

  defp handle_backtick_key(socket) do
    new_state = !socket.assigns.terminal_visible

    {:noreply,
     socket
     |> assign(:terminal_visible, new_state)
     |> push_event("save_terminal_pref", %{visible: new_state})}
  end

  defp handle_other_key(key, socket) do
    # Only process other keys if terminal is visible
    if not socket.assigns.terminal_visible do
      {:noreply, socket}
    else
      process_key_input(key, socket)
    end
  end

  defp process_key_input(key, socket) do
    # Block input during boot sequence
    if socket.assigns.boot_in_progress do
      {:noreply, socket}
    else
      process_key_with_rate_limiting(key, socket)
    end
  end

  defp process_key_with_rate_limiting(key, socket) do
    # Check rate limiting first
    {allowed?, rate_limiter} = InputRateLimiter.allow_event?(socket.assigns.rate_limiter)
    socket = assign(socket, :rate_limiter, rate_limiter)

    if not allowed? do
      # Event blocked by rate limiter
      {:noreply, socket}
    else
      process_key_validation(key, socket)
    end
  end

  defp process_key_validation(key, socket) do
    # Validate input key
    if not valid_input_key?(key) do
      {:noreply, socket}
    else
      # Record activity in adaptive refresh
      adaptive = AdaptiveRefresh.record_activity(socket.assigns.adaptive_refresh)
      process_valid_input(key, socket, adaptive)
    end
  end

  defp valid_input_key?(nil), do: false
  defp valid_input_key?(""), do: false

  defp valid_input_key?(key) when is_binary(key) do
    # Whitelist of allowed keys
    valid_keys = [
      "j",
      "k",
      "h",
      "l",
      "/",
      "Enter",
      "Escape",
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight",
      "Backspace",
      " ",
      ":",
      "q",
      "v",
      "V",
      "t",
      "T",
      "g",
      "G",
      "?",
      "r",
      "m"
    ]

    # Also allow alphanumeric characters for search/command input
    key in valid_keys or (String.length(key) == 1 and String.match?(key, ~r/^[a-zA-Z0-9]$/))
  end

  defp valid_input_key?(_), do: false

  defp process_valid_input(key, socket, adaptive) do
    # Special handling for vim mode toggle - need to notify client for persistence
    socket =
      if key in ["v", "V"] do
        # Send the key to RaxolApp to toggle vim mode
        RaxolApp.send_input(socket.assigns.raxol_pid, key)

        # Get the updated state to check new vim mode value
        # We'll push the event optimistically - assuming toggle worked
        # In a real scenario, we'd want to check the actual state
        # For now, we'll track vim_mode in assigns
        current_vim_mode = Map.get(socket.assigns, :vim_mode, false)
        new_vim_mode = !current_vim_mode

        socket
        |> assign(:vim_mode, new_vim_mode)
        |> push_event("vim_mode_changed", %{enabled: new_vim_mode})
      else
        socket
      end

    # Process key through debouncer (skip if we already sent it for vim mode)
    {debouncer, keys_to_process} =
      if key in ["v", "V"] do
        # Already processed above
        {socket.assigns.input_debouncer, []}
      else
        case InputDebouncer.process_key(socket.assigns.input_debouncer, key) do
          {:immediate, key} ->
            # Process immediately
            RaxolApp.send_input(socket.assigns.raxol_pid, key)
            {socket.assigns.input_debouncer, []}

          {:debounced, new_debouncer} ->
            # Key is being debounced
            {new_debouncer, []}

          {:batched, keys, new_debouncer} ->
            # Process batch of keys
            {new_debouncer, keys}

          {:batch_with_immediate, batch_keys, immediate_key, new_debouncer} ->
            # Process batch then immediate key
            Enum.each(batch_keys, &RaxolApp.send_input(socket.assigns.raxol_pid, &1))
            RaxolApp.send_input(socket.assigns.raxol_pid, immediate_key)
            {new_debouncer, []}

          {:batch_then_start, keys, new_debouncer} ->
            # Process previous batch, start new one
            {new_debouncer, keys}
        end
      end

    # Process any batched keys
    Enum.each(keys_to_process, &RaxolApp.send_input(socket.assigns.raxol_pid, &1))

    # Mark buffer as dirty for immediate render
    adaptive = AdaptiveRefresh.mark_dirty(adaptive)

    {:noreply,
     socket
     |> assign(:adaptive_refresh, adaptive)
     |> assign(:input_debouncer, debouncer)}
  end

  # Schedule next tick based on adaptive refresh rate
  defp schedule_next_tick(adaptive_refresh) do
    interval = AdaptiveRefresh.get_interval_ms(adaptive_refresh)
    Process.send_after(self(), :tick, interval)
  end

  # Helper to convert section atoms to breadcrumb paths
  defp section_to_breadcrumb(:home), do: ["Home"]
  defp section_to_breadcrumb(:projects), do: ["Home", "Projects"]
  defp section_to_breadcrumb(:skills), do: ["Home", "Skills"]
  defp section_to_breadcrumb(:experience), do: ["Home", "Experience"]
  defp section_to_breadcrumb(:contact), do: ["Home", "Contact"]
  defp section_to_breadcrumb(:terminal), do: ["Home", "Terminal"]
  defp section_to_breadcrumb(:search_results), do: ["Home", "Search Results"]
  defp section_to_breadcrumb(:performance), do: ["Home", "Performance"]
  defp section_to_breadcrumb(:matrix), do: ["Home", "Matrix"]
  defp section_to_breadcrumb(:ssh), do: ["Home", "SSH Demo"]
  defp section_to_breadcrumb(:analytics), do: ["Home", "Analytics"]
  defp section_to_breadcrumb(:help), do: ["Home", "Help"]
  defp section_to_breadcrumb(:stl_viewer), do: ["Home", "STL Viewer"]
  defp section_to_breadcrumb(_), do: ["Home"]

  # Screen reader announcements for section changes
  defp announce_section_change(:home), do: "Navigated to Home section"

  defp announce_section_change(:projects),
    do: "Navigated to Projects section. Browse my portfolio projects."

  defp announce_section_change(:skills),
    do: "Navigated to Skills section. View my technical expertise."

  defp announce_section_change(:experience),
    do: "Navigated to Experience section. Review my work history."

  defp announce_section_change(:contact),
    do: "Navigated to Contact section. Get in touch with me."

  defp announce_section_change(:terminal),
    do: "Navigated to Terminal mode. Interactive command line interface."

  defp announce_section_change(:search_results), do: "Showing search results"

  defp announce_section_change(:performance),
    do: "Navigated to Performance Dashboard. Real-time metrics and charts."

  defp announce_section_change(:matrix), do: "Navigated to Matrix plugin. Digital rain effect."

  defp announce_section_change(:help),
    do: "Navigated to Help section. Available commands and keyboard shortcuts."

  defp announce_section_change(:stl_viewer),
    do: "Navigated to STL 3D Viewer. Interactive 3D model viewer."

  defp announce_section_change(_), do: "Section changed"

  # Handle STL viewer actions from keyboard
  defp handle_stl_viewer_action(socket, {:rotate, direction}) do
    angle =
      case direction do
        :up -> -0.1
        :down -> 0.1
        _ -> 0.1
      end

    push_event(socket, "stl_rotate", %{axis: "y", angle: angle})
  end

  defp handle_stl_viewer_action(socket, {:zoom, direction}) do
    # Simulate zoom by moving camera
    distance =
      case direction do
        :in -> -0.5
        :out -> 0.5
        _ -> 0.5
      end

    push_event(socket, "stl_zoom", %{distance: distance})
  end

  defp handle_stl_viewer_action(socket, {:reset, _}) do
    push_event(socket, "stl_reset", %{})
  end

  defp handle_stl_viewer_action(socket, {:cycle_mode, _}) do
    push_event(socket, "stl_cycle_mode", %{})
  end

  defp handle_stl_viewer_action(socket, _), do: socket

  # Handle Spotify actions from keyboard
  defp handle_spotify_action(socket, :play_pause) do
    Droodotfoo.Spotify.play_pause()
    socket
  end

  defp handle_spotify_action(socket, :next_track) do
    Droodotfoo.Spotify.next_track()
    socket
  end

  defp handle_spotify_action(socket, :previous_track) do
    Droodotfoo.Spotify.previous_track()
    socket
  end

  defp handle_spotify_action(socket, :volume_up) do
    Droodotfoo.Spotify.adjust_volume(:up)
    socket
  end

  defp handle_spotify_action(socket, :volume_down) do
    Droodotfoo.Spotify.adjust_volume(:down)
    socket
  end

  defp handle_spotify_action(socket, :refresh) do
    Droodotfoo.Spotify.refresh_now_playing()
    socket
  end

  defp handle_spotify_action(socket, :start_auth) do
    case Droodotfoo.Spotify.start_auth() do
      {:ok, url} ->
        # Push event to JS to open browser
        push_event(socket, "open_url", %{url: url})

      {:error, _} ->
        socket
    end
  end

  defp handle_spotify_action(socket, _), do: socket

  # Handle Web3 actions
  defp handle_web3_action(socket, :connect) do
    # Generate a temporary nonce (will be replaced by one from the backend)
    # For now, we'll generate it client-side in the JavaScript hook
    # Just push the event to trigger MetaMask
    push_event(socket, "web3_connect_request", %{})
  end

  defp handle_web3_action(socket, :disconnect) do
    # Clear wallet session (get session ID from RaxolApp state)
    # For now, just update the RaxolApp state
    RaxolApp.set_web3_wallet(socket.assigns.raxol_pid, nil, nil)

    socket
  end

  defp handle_web3_action(socket, _), do: socket

  # Render boot sequence to HTML
  defp render_boot_sequence(step) do
    lines = BootSequence.render(step)

    # Convert lines to simple HTML with monospace styling
    Enum.map_join(lines, "\n", fn line ->
      # Escape HTML and preserve spaces
      "<div class=\"terminal-line\">#{Phoenix.HTML.html_escape(line) |> Phoenix.HTML.safe_to_string()}</div>"
    end)
  end

  # Configuration function for switching between terminal bridges
end
